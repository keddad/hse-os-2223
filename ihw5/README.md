# ДЗ5

Бирюлин Никита Андреевич, БПИ213

В messenger.c представлена программа, которая с помощью именованных каналов общается с собой же, запущенной в другом процессе. Названия каналов передаются из командной строки.

Сборка через 

```
make messenger
```

Для демонстрации необходимо параллельно запустить программу в двух экземплярах. Синтаксис:
```
./messenger read_fifo_name write_fifo_name
```

Пример работы:

```
[keddad@fedora ihw5]$ ./messenger 2 1
Current PID: 57850 Other PID: 57849
Send message 519726794
Read message: 1912652866
Send message 867144625
Read message: 1071103357
Send message 333498767
Read message: 774127162
```

```
[keddad@fedora ihw5]$ ./messenger 1 2
Current PID: 57849 Other PID: 57850
Read message: 519726794
Send message 1912652866
Read message: 867144625
Send message 1071103357
Read message: 333498767
Send message 774127162
```

В этом примере программы сначала обменялись своими PID, чтобы выбрать "лидера", который отправит первое сообщение (программа с большим PID отправляет первой), после чего поочередно отправляют друг другу некие важные числа.

В процессе написания программы я столкнулся с проблемой:
* Если канал открывается блокирующе, open(..., O_RDONLY) не разблокируется пока другой процесс не вызовет open(..., O_WRONLY), что в текущей ситуации приводит к дедлоку.
* Если делать open(..., O_RDONLY | O_NONBLOCK), open не блокируется, но не блокируются и read => если другой процесс не успевает записать данные (а он почти всегда не успевает), read возвращает -1, мы падаем с ошибкой.
* Решением было открыть канал для чтения с O_NONBLOCK, после чего снять его через fcntl.